<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Code Crush for programming paradigms</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://kit.fontawesome.com/a076d05399.js"></script>
    <link rel="apple-touch-icon" sizes="180x180" href="favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon/favicon-16x16.png">
    <link rel="manifest" href="favicon/site.webmanifest">
  </head>
  <body>

    <input type="checkbox" id="check">
    <label for="check">
      <i class="fas fa-bars" id="btn"></i>
      <i class="fas fa-times" id="cancel"></i>
    </label>
    <div class="sidebar">
    <header><i class="fab fa-gratipay"></i>Code Crush</header>
  <ul>
    <li><a href="index.html"><i class="fas fa-home"></i>Home</a></li>
    <li><a href="structural.html"><i class="fas fa-link"></i>Structural</a></li>
    <li><a href="procedural.html"><i class="fas fa-stream"></i>Procedural</a></li>
    <li><a href="objectoriented.html"><i class="fas fa-angle-double-right"></i>Object Oriented</a></li>
    <li><a href="eventdriven.html"><i class="far fa-calendar-check"></i>Event Driven</a></li>
    <li><a href="declarative.html"><i class="fas fa-sliders-h"></i>Declarative</a></li>
    <li><a href="imperative.html"><i class="far fa-envelope"></i>Imperative</a></li>
    <li><a href="parallel"><i class="fas fa-equals"></i>Parallel</a></li>
    <li><a href="concurrent.html"><i class="fas fa-database"></i>Concurrent</a></li>
    <li><a href="functional.html"><i class="fas fa-percent"></i>Functional</a></li>
    <li><a href="logic.html"><i class="fas fa-sign-in-alt"></i>Logic</a></li>
    <li><a href="#"><i class="fas fa-balance-scale-right"></i>Dependent</a></li>
    <li><a href="network.html"><i class="fas fa-wifi"></i>Network</a></li>
    <li><a href="symbolic.html"><i class="fas fa-mouse-pointer"></i> Symbolic</a></li>
    <li><a href="automata.html"><i class="fas fa-anchor"></i>Automata</a></li>
    <li><a href="gui.html"><i class="fas fa-gamepad"></i>GUI</a></li>

  </ul>
</div>

       <section>

         <div class="topnav">
       <li><a href="index.html"><i class="fas fa-home"></i> Home</a></li>
       <a href="about/index.html"><i class="fas fa-user-circle"></i> About</a>
       <a href="https://forms.gle/Dw47JDVJr4tQo7j26"><i class="far fa-bell"></i> Notify</a>
       <input type="text" placeholder="Search..">
     </div>
          <h1>Dependent Programming Paradigms</h1>
              <div class="main">

<p>In computer science and logic, a dependent type is a type whose definition depends on a value. It is an overlapping feature of type theory and type systems. In intuitionistic type theory, dependent types are used to encode logic's quantifiers like "for all" and "there exists". In functional programming languages like Agda, ATS, Coq, F*, Epigram, and Idris, dependent types may help reduce bugs by enabling the programmer to assign types that further restrain the set of possible implementations.</p>
<br>
<p>Two common examples of dependent types are dependent functions and dependent pairs. The return type of a dependent function may depend on the value (not just type) of one of its arguments. For instance, a function that takes a positive integer {\displaystyle n} n may return an array of length {\displaystyle n} n, where the array length is part of the type of the array. (Note that this is different from polymorphism and generic programming, both of which include the type as an argument.) A dependent pair may have a second value of which the type depends on the first value. Sticking with the array example, a dependent pair may be used to pair an array with its length in a type-safe way.</p>
<br>
<p>Dependent types add complexity to a type system. Deciding the equality of dependent types in a program may require computations. If arbitrary values are allowed in dependent types, then deciding type equality may involve deciding whether two arbitrary programs produce the same result; hence type checking may become undecidable.</p>
</div>

     <div class="main2">
         <p><span style="color:#52D273;font-weight:bold">HISTORY</span></p><br>
<p>Dependent types were created to deepen the connection between programming and logic.</p>
<br>
<p>In 1934, Haskell Curry noticed that the types used in typed lambda calculus, and in its combinatory logic counterpart, followed the same pattern as axioms in propositional logic. Going further, for every proof in the logic, there was a matching function (term) in the programming language. One of Curry's examples was the correspondence between simply typed lambda calculus and intuitionistic logic.</p>
<br>
<p>Predicate logic is an extension of propositional logic, adding quantifiers. Howard and de Bruijn extended lambda calculus to match this more powerful logic by creating types for dependent functions, which correspond to "for all", and dependent pairs, which correspond to "there exists".</p>
      <br>     </div>
      <div class="video">

           <iframe width="560" height="315" src="https://www.youtube.com/embed/-Ti8Ja1W3lo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
           

         </div>

      </section>
  </body>
</html>
